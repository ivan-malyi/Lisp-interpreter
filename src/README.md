Синтаксический парсер — это алгоритм, который принимает данные специального типа структуры (Token), из которых он строит AST дерево, которое
затем может обходить и анализировать.

    1.List(Vec<LispVal>) - нам нужен для вложености.
    2.Токен - это структура, которая хранит в себе все о символе.
    3.Lisp выражение - строится из токенов, где начало - открывающая скобка а окончание - закрывающая. Благодаря List(Vec<LispVal>) мы вкладываем эту структуру, образуя Lisp выражение.
    4.Программа строится из Lisp выражений. По сути программа - это будет наше окончательное дерево.
    5. Окончательное дерево - это вектор векторов, который генеерируется как результат интерпритации всего исхожного кода. Образуется только 
    при условии отсутсвия векторов в области "новый код" в ряду перенесения всего в область "готового кода". Вектора хранятся в особой структуре -
    - 'ReadyVec'. 
    Поиск по древу происходит за O(1), т.к он подобен хэш-таблице и ищет элементы по хэшу.
    Это нам подойдет при повторном запуске интерпритатора на том самом коде. 
    По сути, рекомендую представлять каждый запуск интерпритации - как желание сгенерировать новое древо, но мы не хотим каждый раз выполнять,
    во многом одни интерпреционные действия с векторами, поэтому мы будем анализировать векторы на наличие в нашем древе (по хэшу) и соответсвие его колонке, т.к последовательность - это важный аспект при анализе кода и коммутативность тут наблюдается крайне редко следовательно изменение в располажении
    какого либо из векторов должно вести за собой полную переинтерпритацию древа. (Или ветви можно как то поменять местами ? )

    Другой вопрос косается удаление векторов (фрагментов из кода) либо их изменения , в то время как другие части остаются статическимм: во первых следует понимать, что




    удаление какого-либо вектора, в новой попытке интерпритировать, влечет за собой изменения расположения каждого з векторов на n-1, с добавлением 
    дело обстоит иначе : код делится на код, на ряды которого подействуют изменнения(который следует после добавленной строки) - они станут n+1, и 
    код ряды которого останется статическим - в таком случае уместно затронуть только ряды, на которых влияют изменения (как увелечение номера строки, так и возможное течение кода). 
    Для реализации  этого следует разработать своего рода весы, которые будут выдавать на выходе какое то число (коэффициент), анализируя которое
    мы способны понять нужно ли нам повторно пересоьирать дерево, либо же мы можем обойтись изменением конструкции некоторых векторов - что будет 
    куда эффективней и   



TODO: 
    1. Первое что следует сделать - это преобразователь потока в ветвь (вектор): ветвь в своем роде просто вектор. У каждой ветви есть свой 
    регламент: 
        - Она начинается с открывающей скобки и заканчивается на первую встречную закрывающую
        - Вторым после открывающей скобки должен идти операнд 
        - Третьим, четвертым ... идут аргументы.
            - Аргумент в свою очередь тоже может быть веткой(вектором). В такой случае мы получаем вектор с вложеным(и) в себя векторами.
            Тогда нам нужно добраться сначала до самого вложенного и выполнить его первым и рекрсивно вернуть результат.

    2. Мы реализовали структуру и методы для раблоты с вектором токеном
        - Предполагается следующий алгоритм дейсвий:
            1. Инициализация и создание вектора токена, с помощью метода new 
            2. Использования методов итерирования и чтения конкретного токена
            3. Метод проверяющий текущий указатель токена и контролирующий его от выход за пределы вектора (для этого была введен параметр 
            'vec_len' в сруктуре 'Parse', дабы избежать постоянного вычесления длины вектора в методе 'is_at_end()', который по предположению
            должен использоваться довльно часто, например в while цикле)


    3. Передаваеммые вектора 
        Передаваеммый вектор на даннном этапе = это конктретная строка, которая по сути заканчивается b'\n'.
        Т.к мы разрабатываем интерпритатор - то мы будем производить чтение и анализ - по строчно. 
        Следовательно, n строк кода - n ветвьей (векторов), образующие с интерпритируемое дерево.
        Лексический анализатор будет передавать по-векторно данные. Он может делать это и потоком, но тогда он должен 
        предоставить функционал для работы с ним : извлечения из потока конкретный вектор, итерацию по потоку и тд.




    4. Дополнение
        - Умный интерпритатор: у нас буду две области обработки кода - уже с интерпритируемая и "новый код". Каждый вектор, переходя 
        с области "новый код" в области уже обработанного кода сохраняется в новой структуре, где в обязательном порядке указан его хэш.